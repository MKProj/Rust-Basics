<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Basics</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="02-bindings.html"><strong aria-hidden="true">2.</strong> Bindings &amp; Mutability</a></li><li class="chapter-item expanded "><a href="03-imports.html"><strong aria-hidden="true">3.</strong> Imports &amp; Namespaces</a></li><li class="chapter-item expanded "><a href="04-cf.html"><strong aria-hidden="true">4.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="05-mod.html"><strong aria-hidden="true">5.</strong> Modules &amp; Functions</a></li><li class="chapter-item expanded "><a href="06-cargo.html"><strong aria-hidden="true">6.</strong> Cargo</a></li><li class="chapter-item expanded "><a href="07-owner.html"><strong aria-hidden="true">7.</strong> Ownership Basics</a></li><li class="chapter-item expanded "><a href="08-struct.html"><strong aria-hidden="true">8.</strong> Structs &amp; Enums</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Basics</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/MKProj/Rust-Basics.git" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Rust is a systems programming language that combines the speeds of a low level programming 
language, as well as the memory safety with a high programming language. This makes Rust 
a very impressive language as these aspects are an either or, however Rust is able to 
reach this with it's ideals of Ownership, and the fact that it does not use a garbage collector.</p>
<p>Rust was developed by Graydon Hoare at Mozilla Research, and it first publically appeared at July 7, 2010, since then it developed its own foundation funded by many corporations, and is called the Rust Foundation, 
. It has gained remarks of a language not only similar in syntax to C++, but could possibly start replacing it in a company's application for more safe and secure code. This has proved to 
be true for MKProjects as the first command line project was written in C++, but however the reliability 
of an infinite loop is anything but reliable, so looking into Rust has been a good decision as 
it now runs most of the projects, even this book is created using Rust!!!</p>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<p>To install Rust, it is recommended to install via Rustup so visit <a href="http://rustup.rs">rustup.rs</a></p>
<h2 id="rust-compiler"><a class="header" href="#rust-compiler">Rust Compiler</a></h2>
<p>In the first few sections we will be utilizing the Rust Compiler, 
and it used as <code>rustc file.rs</code> which will create a binary that can 
be executed. In this book, it will reflect upon the linux terminal, 
however Unix Systems like MacOS will not differ, and Windows will
have <code>.exe</code> files instead of binary files. </p>
<h2 id="extra-resources"><a class="header" href="#extra-resources">Extra Resources</a></h2>
<p>Keep in mind this is only an entry point into Rust and obviously doesn't cover everything that Rust offers, (and trust me there's a lot), so it is 
good to look into extra resources, and good for you that the Rust Foundation already has you covered. </p>
<ul>
<li>
<p><a href="https://doc.rust-lang.org/book/">The Book</a></p>
<ul>
<li>This is a good introduction to Rust and can cover more topics in better detail</li>
</ul>
</li>
<li>
<p><a href="https://doc.rust-lang.org/stable/rust-by-example/">Rust By Example</a></p>
<ul>
<li>Learn Rust in a more interactive way with examples</li>
</ul>
</li>
<li>
<p><a href="https://rust-cli.github.io/book/index.html">Command Line Book</a></p>
<ul>
<li>Create Command Line applications using Structopts </li>
</ul>
</li>
<li>
<p><a href="https://rustwasm.github.io/docs/book/">WebAssembly Book</a></p>
<ul>
<li>Create Web applications with Rust and Webassembly</li>
</ul>
</li>
<li>
<p><a href="https://doc.rust-lang.org/embedded-book">Embedded Book</a></p>
<ul>
<li>Created programs for embedded system with Rust</li>
</ul>
</li>
</ul>
<p>There is many more books provided by the Rust Foundations, so make sure 
to <a href="https://www.rust-lang.org/learn">check out it out!</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bindings--mutability"><a class="header" href="#bindings--mutability">Bindings &amp; Mutability</a></h1>
<p>In Rust, another way of calling a binding is a variable. A binding is used as a placeholder to store memory of a particular value, and in Rust, by default is set to immutable. Before talking more about this, let's first look at how to declare a binding, one with type inference, and the other with an explicit type: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 5.0; //Inferred by default as float64 or f64
let b: f64 = 5.0; //Explicitly declared as type f64
<span class="boring">}
</span></code></pre></pre>
<p>To delcare a binding, you must use the <code>let</code> keyword with a purposeful name 
and an assignment operator, <code>=</code>, with an appropriate value with it. Due to Rust 
being a safe memory language, all bindings are immutable by default, and this is different than most languages, however you'll see most of the times mutability isn't 
necessary. But that doesn't mean mutability isn't possible, it is instead initiated with the convenient <code>mut</code> keyword. </p>
<pre><pre class="playground"><code class="language-rust">fn main(){
    let mut a = &quot;I am Mutable&quot;; 
    a = &quot;I can change values!!!&quot;; 
    
    let b = &quot;I am immutable&quot;; 
    b = &quot;This will cause an error!&quot;;
    //Press play to check the error!
}
</code></pre></pre>
<h2 id="data-types"><a class="header" href="#data-types">Data Types</a></h2>
<hr />
<p>Rust has four main data types, which are the following: </p>
<ul>
<li>Integers (non decimal point numbers) 
<ul>
<li>Signed: <code>i8, i16, i32, i64, i128, isize</code></li>
<li>Unsigned: <code>u8, u16, u32, u64, u128, usize</code></li>
</ul>
</li>
<li>Floating Points (decimal point numbers)
<ul>
<li><code>f32 or f64(inferred default)</code></li>
</ul>
</li>
<li>Boolean
<ul>
<li><code>bool</code>, either evaluates to <code>true or false</code></li>
</ul>
</li>
<li>Characters 
<ul>
<li><code>char</code>, such as <code>'L'</code></li>
</ul>
</li>
</ul>
<p>Another type that is commonly used but not primitive is Strings
and is denoted by <code>String</code>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="imports--namespaces"><a class="header" href="#imports--namespaces">Imports &amp; Namespaces</a></h1>
<p>In many languages it is common to import libraries from external, or standard libraries, in our case we will only consider the standard library until we talk about <a href="06-cargo.html">Cargo in Section 6</a>. So I guess the best way to start is by first figuring out how to import a library, and that is done by the <code>use</code> keyword. </p>
<p>To help with this section, we will create a simple user input program by using the standard library input/output module ,<code>std::io</code>. </p>
<pre><pre class="playground"><code class="language-rust">use std::io;

fn main() {
    let mut input = String::new(); // Creates a new String
    io::stdin().read_line(&amp;mut input).unwrap();
    println!(&quot;Your input is {}&quot;, input);
    /*
    What this means is that we borrow (&amp;) the binding input, and
    it must be mutable, since it will change it's value
    */
}
</code></pre></pre>
<p>In this example, we specify that we only want to use the <code>io</code> module in the 
<code>std</code> library. However let's say we don't know what we really want from the <code>std</code> 
library, and instead of guessing, we could just import everything by using <code>*</code> after 
<code>std::</code>. </p>
<p>Consider the example below: </p>
<pre><pre class="playground"><code class="language-rust">use std::*;

fn main() {
    //We will be copying one file to another
    let mut a = fs::File::create(&quot;file.txt&quot;).expect(&quot;file not created&quot;);

    //The file we will be copying from
    let mut b = fs::File::open(&quot;copy.txt&quot;).expect(&quot;file not found&quot;);
    //Using io to copy b to a
    io::copy(&amp;mut b, &amp;mut a).expect(&quot;file cannot be copied&quot;);
}
</code></pre></pre>
<p>We get the following result: </p>
<pre><code class="language-bash">$ rustc ex.rs
$ ./ex

#copy.txt
This file has words!!!

#file.txt
This file has words!!!
</code></pre>
<p>As you can see we could access anything from <code>std</code> using <code>*</code>, however it isn't the
most effective thing to do, in this example we only needed <code>io</code> and <code>fs</code> modules, so 
let's just import those. </p>
<pre><pre class="playground"><code class="language-rust">use std::{fs, io};

fn main() {
    //We will be copying one file to another
    let mut a = fs::File::create(&quot;file.txt&quot;).expect(&quot;file not created&quot;);

    //The file we will be copying from
    let mut b = fs::File::open(&quot;copy.txt&quot;).expect(&quot;file not found&quot;);
    //Using io to copy b to a
    io::copy(&amp;mut b, &amp;mut a).expect(&quot;file cannot be copied&quot;);
}
</code></pre></pre>
<p>As you can see, if you know what you want to import, and need multiple modules, then
surround them with <code>{ }</code>. </p>
<blockquote>
<p>Keep in mind, when it comes to namespaces, whatever the module you import is the name
you must start with. Example <code>std::io</code> you use <code>io::</code>, but if you did <code>std::fs::File</code>, you must start with <code>File::</code></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<h2 id="if-statements"><a class="header" href="#if-statements">If Statements</a></h2>
<p>An <code>if</code> statement is a block of code that can be executed by a program if 
a condition results to <code>true</code>. For example let's ask the user for a number 
from 1 to 10, if it's less than 5, we will say <code>&quot;Wow that's low huh!&quot;</code>. </p>
<pre><pre class="playground"><code class="language-rust">use std::io::stdin; //To get standard input 

fn main(){
    let mut input = String::new();
    println!(&quot;Enter a number from 1 to 10!&quot;);
    stdin().read_line(&amp;mut input).unwrap(); //Gets user input 

    //Now to convert the String to i32
    let i:i32 = input.trim().parse().expect(&quot;Expected an integer&quot;);

    if i &lt; 5 {
        println!(&quot;Wow that's low huh!&quot;);
    }
}
</code></pre></pre>
<blockquote>
<p>As you can see, we have the <code>if</code> keyword followed by the condition, such as <code>i &lt; 5</code> 
then the block of code executed is surrounded by <code>{ }</code>. </p>
</blockquote>
<h2 id="else-clause"><a class="header" href="#else-clause">Else Clause</a></h2>
<p>This program isn't really that good, it only gives you something if you guess a number less than 5, but let's say I guess 8? I should still get something, and that's when the <code>else</code> clause comes in, unlike the <code>if</code> statement, it will execute a block of code 
only if it results to <code>false</code>. So let's fix our program so when I guess 5 or greater I am presented with <code>&quot;Buddy you guessed too high!&quot;</code>. </p>
<pre><pre class="playground"><code class="language-rust">use std::io::stdin; //To get standard input 

fn main(){
    let mut input = String::new();
    println!(&quot;Enter a number from 1 to 10!&quot;);
    stdin().read_line(&amp;mut input).unwrap(); //Gets user input 

    //Now to convert the String to i32
    let i:i32 = input.trim().parse().expect(&quot;Expected an integer&quot;);

    if i &lt; 5 {
        println!(&quot;Wow that's low huh!&quot;);
    } else {
        println!(&quot;Buddy you guessed too high!&quot;);
    }
}
</code></pre></pre>
<blockquote>
<p>Notice how when you're using the <code>else</code> clause, you don't require a 
condition, since it's like a default.</p>
</blockquote>
<h2 id="else-if-statement"><a class="header" href="#else-if-statement">Else if Statement</a></h2>
<p>Now I got another problem with my program, I want something to happen when they guess 
5, so how do I do that, add another <code>if</code> statement? But that would look so disgusting, 
so instead why not add an <code>else if</code> statement? An <code>else if</code> statement is like a second order condition, if the first <code>if</code> statement results to false, then the <code>else if</code> statement is checked, and if it results to <code>true</code> then it's block of code is executed. </p>
<pre><pre class="playground"><code class="language-rust">use std::io::stdin; //To get standard input 

fn main(){
    let mut input = String::new();
    println!(&quot;Enter a number from 1 to 10!&quot;);
    stdin().read_line(&amp;mut input).unwrap(); //Gets user input 

    //Now to convert the String to i32
    let i:i32 = input.trim().parse().expect(&quot;Expected an integer&quot;);

    if i &lt; 5 {
        println!(&quot;Wow that's low huh!&quot;);
    } else if i == 5{
        println!(&quot;You guessed right!!!&quot;);
    } else {
        println!(&quot;Buddy you guessed too high!&quot;);
    }
}
</code></pre></pre>
<blockquote>
<p>An <code>else if</code> statement has the same syntax as an <code>if</code> statement, except it must be 
after an <code>if</code> statement and before the <code>else</code> clause. </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules--functions"><a class="header" href="#modules--functions">Modules &amp; Functions</a></h1>
<h2 id="function-syntax"><a class="header" href="#function-syntax">Function Syntax</a></h2>
<p>A function in Rust is defined with the <code>fn</code> keyword and is a block of code 
that uses parameters to pass arguments and returns a value or values. To create a 
function first use the <code>fn</code> keyword along with a name, then put brackets<code>()</code> that will 
contain the parameters, and then <code>{}</code> for your block of code.</p>
<p>To make this a lot simpler, observe a simple <code>hello_world()</code> function that asks 
for a name and prints <code>&quot;Hello World Name!&quot;</code>. To do this we will also require a 
parameter name that's a <code>String</code>. </p>
<pre><pre class="playground"><code class="language-rust">//Let's define our hello_world function
fn hello_world(name: &amp;String){
// Since we don't want to entirely use the variable 
// We will borrow it using &amp;
    println!(&quot;Hello World {}!&quot;, name);
}

fn main(){
    let mut name: String = String::from(&quot;Bob&quot;);

    //To call a function simply use it's name
    hello_world(&amp;name);
}
</code></pre></pre>
<h3 id="return-type"><a class="header" href="#return-type">Return Type</a></h3>
<p>When you write a function in Rust, you can either return nothing, in other 
languages that may be called a <code>void</code> function, or you can return a data type using <code>fn foo()-&gt;type{}</code>. For our example we will create a simple add function to show an easy example to return: </p>
<pre><pre class="playground"><code class="language-rust">fn add(a:i32, b:i32)-&gt;i32{
    a + b 
}
//Another way of returning is: 
fn add_alt(a:i32, b:i32)-&gt;i32{
    a + b
}
fn main(){
    let a = add(2,5);
    let b = add_alt(2,5);

    if a == b{
        println!(&quot;Same result&quot;);
    }
}
</code></pre></pre>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<p>To introduce modules we will be writing a program that involves two files, 
we will respectively have <code>lib.rs</code> and <code>main.rs</code>. We will have two different sections or modules in our library, one being for geometry of 2D shapes and the other for 3D. To define a module, we must use the <code>mod</code> keyword.</p>
<blockquote>
<p>To have functions able to use outside of the module or library, make sure
to use the <code>pub</code> keyword to make it public (private by default). </p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//lib.rs
mod 2D{
    pub fn Area(len: f64, width: f64)-&gt;f64{
        len*width; 
    }
}
mod 3D{
    pub fn Volume(len: f64, width: f64, height: f64){
        len * width * height;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now to import our library, we must first <code>mod</code> it then we can <code>use</code> the 
library, so let's do that. </p>
<pre><pre class="playground"><code class="language-rust">//main.rs 
mod lib; 
use lib::2D;
use lib::3D;

fn main(){
    /* 
    Let's find the area and volume of 
    a square and cube respectively. 
    */  
    let side = 2.56;
    println!(&quot;Area: {}&quot;, Area(side, side));
    println!(&quot;Volume: {}&quot;, Volume(side, side, side));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo"><a class="header" href="#cargo">Cargo</a></h1>
<p>Cargo is Rust's package manager utility and is the recommended way to build a Rust program as it allows the ability to import crates, and publish your own. It is very convenient to the user, and offers two different type of projects to be built: </p>
<ul>
<li>bin : A binary project is a project to be executable (default)</li>
<li>lib: A library is a way to store all your functions, modules, etc. seperately
A crate in Rust is a cargo project published in Rust's <code>(http://crates.io)[crates.io]</code>.<br />
To create a new cargo project, we use the <code>cargo new</code> option, and provided a name will create a project for us with the following structure: </li>
</ul>
<pre><code class="language-bash">$ cargo new myproject # Create binary crate myproejct
$ cd myproject
$ ls
Cargo.toml src
</code></pre>
<p>The <code>src</code> directory contains all of our source code, and inside the folder contains a <code>main.rs</code> file for us to do our work. 
The <code>Cargo.toml</code> file contains all of the metadata for out project such as name, author, version number, dependencies, etc. 
For more information about what can be done in Cargo, you can visit (https://doc.rust-lang.org/cargo/index.html)[here]. </p>
<p>For our example, we will make use of the <code>rand</code> crate to create randomized numbers for a guessing game. </p>
<pre><code class="language-bash">$ cargo new guess_game # create a new guess_game
$ cargo search rand # let's find the version number of the crate
rand = &quot;0.8.4&quot;      # Random number generators and other randomness functionality.
</code></pre>
<p>Let's first edit our <code>Cargo.toml</code> file and add the <code>rand</code> crate as a dependency.</p>
<pre><code class="language-toml">#Cargo.toml
[package]
name = &quot;myproject&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
rand = &quot;0.8.4&quot;
</code></pre>
<p>Now that we have rand as a dependency,we are free to use it in our project. 
Now we can edit our <code>src/main.rs</code> file and begin our guessing game that does the following: </p>
<ul>
<li>The user only has one attempt to try</li>
<li>We will tell them if they are too low or too high</li>
<li>They will have to guess from 1 to 10</li>
</ul>
<pre><pre class="playground"><code class="language-rust">use rand::Rng;// For rand numbers
use std::cmp::{Ord, Ordering};// For Ordering 
fn main() {
   let rng = rand::thread_rng().gen_range(1..10);//Our random number generator

   let mut s = String::new();//Use to get user input
   println!(&quot;Enter your guess: &quot;);// Ask for input
   std::io::stdin().read_line(&amp;mut s).unwrap();

   let guess: i32 = s.trim().parse().unwrap();

   //Now we match our guess to compare with our random number
   match guess.cmp(&amp;rng) {
       Ordering::Greater =&gt; println!(&quot;Too high!&quot;),
       Ordering::Less =&gt; println!(&quot;Too low!&quot;),
       Ordering::Equal =&gt; println!(&quot;You're right!&quot;),
   }
}
</code></pre></pre>
<p>You can try yourself running <code>cargo run</code> and see if you guess right. You may also build 
the project by running, <code>cargo build</code>, and the executable will be found in <code>target/debug/&lt;name&gt;</code>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-basics"><a class="header" href="#ownership-basics">Ownership Basics</a></h1>
<p>Rust follows a memory/thread safe, zero abstraction model and due to that a Garbage Collector won't comply. A GC automatically 
handles the drops and move between data in the program, and due to that it costs some performance for that memeory management. </p>
<p>So what do we do then? Well Rust uses ownerships rules to comply with Rust's Borrow Checker that ensures memory safety, however
in this book we won't go into much detail of Rust's handling with stack and heap allocation, but we will show enough to avoid 
fighting the borrow checker. </p>
<h3 id="ownership-rules"><a class="header" href="#ownership-rules">Ownership Rules</a></h3>
<ul>
<li>Each value in Rust has a variable that's called it's <strong>owner</strong></li>
<li>There can only be one owner at a time</li>
<li>When the owner goes out of scope, the value will be dropped</li>
</ul>
<p>We can see a simple example using closures: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{ //my_var isn't valid, isn't declared yet'
    let my_var = &quot;My Variable exists here!&quot;; //valid from this point forward
    //Do stuff with my_var
} //The scope is over, so my_var is dropped
<span class="boring">}
</span></code></pre></pre>
<p>Now we introduce the concept of borrowing, and this is done by using the <code>&amp;</code> operator. Borrowing allows other 
variables to use a variables data, and we have two ways of borrowing, we have <code>&amp;</code> (immutable borrow) and <code>&amp;mut</code> 
(mutable borrow) where mutable borrow allows for us to manipulate the data. </p>
<pre><pre class="playground"><code class="language-rust">// This program borrows a vec and pushes 2 into it 
fn push_two(v: &amp;mut Vec&lt;i32&gt;){
    v.push(2);
}
fn main(){
    let mut v = vec![1,6,7,8];
    push_two(&amp;mut v);
    println!(&quot;{:?}&quot;, v)
}
//Result: [1, 6, 7, 8, 2]
</code></pre></pre>
<h3 id="string-and-strs"><a class="header" href="#string-and-strs">String and strs</a></h3>
<p>If you havent noticed, but Rust has two different type of string types, <code>String</code> and <code>&amp;str</code>, and this 
can be explained due to ownership. A <code>String</code> variable is an owned value, and this means if you move the value from
one variable to another, the new variable now owns the value and the other variable is dropped. Now the other string type 
<code>&amp;str</code> is the reference to a string, or a borrowed version. So if you move one value to the other, both are still valid, 
and these both have it's use cases and it's important to note that in functions it is common to use <code>&amp;str</code> instead of <code>String</code> (due to borrowing the parameter). </p>
<p>This guide doesn't go into the finer details of the ownership rules in Rust and it is highly recommend to read the documentation provided by the Rust Foundation <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">here for more details.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs--enums"><a class="header" href="#structs--enums">Structs &amp; Enums</a></h1>
<p>Compared to other languages like C++, Rust does not offer Classes, however instead it's concepts are 
found in structs &amp; enums which are used to create custom types in programs. Let's first start of with structs 
which are common to find in C#, Java, C etc. </p>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<p>There are three type of structs that exist in Rust, we have: </p>
<ol>
<li>Empty Structs </li>
<li>Tuple Structs </li>
<li>Structs </li>
</ol>
<p>An empty struct is literally what you think, it contains no parameters and tend to be used as a placeholder in programs. A struct can be defined as <code>stuct &lt;name&gt;</code>, so an empty struct would look like: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct IamEmpty;
<span class="boring">}
</span></code></pre></pre>
<p>A tuple struct is a struct that has no parameters, but instead just asks for the data type, this you can see right below: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct tupleStruct(i32, f32, String);
<span class="boring">}
</span></code></pre></pre>
<p>As you can see it looks like a tuple, and doesn't set parameters with actual names.<br />
The last one is the classic C struct where parameters and data types are provided, and is the most common type of struct you'll use or encounter. </p>
<pre><pre class="playground"><code class="language-rust">struct classic{
    a: i32, 
    b: f32, 
    c: String
}

fn main(){
    let c: classic = classic{
        a: 2, 
        b: 7.8, 
        c: &quot;Hello&quot;.to_owned()
    }; //To invoke a struct
}
</code></pre></pre>
<p>Enums are more custom, as it's not necessary to actually have a data type, of course depending on the context of the program. Let's create a color enum: </p>
<pre><pre class="playground"><code class="language-rust">enum Color{
    Red(u8), 
    Green(u8),
    Blue(u8)
}

fn main(){
    let red = Color::Red(255);
    let green = Color::Green(255);
    let blue = Color::Blue(255);
}
</code></pre></pre>
<p>Of course this is still limiting of what we can do, and that's where implementations come in, these provide functions for our structs or enums. Now let's create a struct for Points and put some functions in it. </p>
<pre><pre class="playground"><code class="language-rust">//To make implementations we need to use the impl keyword
struct Points{
    x: f32,
    y: f32,
}

impl Points{
    fn new (x: f32, y: f32)-&gt; Self {
        //Similar to a constructor 
        Self{
            x,
            y
        }
    }
    fn slope(&amp;self, other: &amp;Points)-&gt; f32{
        (other.y - self.y) / (other.x - self.x)
    }
    fn midpoint(p1: &amp;Points, p2: &amp;Points)-&gt; Self{
        Self{
            x: (p1.x + p2.x) / 2.0, 
            y: (p1.y + p2.y) / 2.0
        }
    }
}

fn main(){
    let p1 = Points::new(7.8, 8.9);
    let p2 = Points::new(9.8,6.7);

    let midpoint = Points::midpoint(&amp;p1,&amp;p2);
    //Any methods returning Self use ::
    //Any methods not returning Self use .

    println!(&quot;The midpoint of p1 to p2 is x: {} y: {}&quot;, midpoint.x, midpoint.y);
    //The midpoint of p1 to p2 is x: 8.8 y: 7.7999997
    println!(&quot;While the slope of p2 to p1 is {}&quot;, p1.slope(&amp;p2));
    //While the slope of p2 to p1 is -1.0999999
}
</code></pre></pre>
<!--
- Empty struct
- Tuple struct
- classic strut

- enums 

- implementations >
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
